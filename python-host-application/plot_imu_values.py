# Based on https://github.com/nasrAnthony/IMU-position-tracker/blob/master/IMU_motion_tracker.py
# Original author: Anthony Nasr
# Original date: 2024-04-06

import csv
import numpy as np
import matplotlib.pyplot as plt
import copy

class data_container():
    '''
    This section of the code deals with the data generated by the C0 MicroSD
    '''

    def __init__(self):
        # Change this to target file name.
        self.file_name = 'output_results.csv'
        self.list_acc_data = []
        self.acc_x = []  # acc data just in x
        self.acc_y = []  # acc data just in y
        self.acc_z = []  # acc data just in z
        self.acc_post_fitler_x = []  # acc data just in x
        self.acc_post_fitler_y = []  # acc data just in y
        self.acc_post_fitler_z = []  # acc data just in z
        self.read_content()

    # getters:
    def get_acc_data(self) -> list[float]:
        return self.list_acc_data

    def get_acc_x_pre_fitler(self):
        return self.acc_x

    def get_acc_y_pre_fitler(self):
        return self.acc_y

    def get_acc_z_pre_fitler(self):
        return self.acc_z

    def get_acc_x_post_fitler(self):
        return self.acc_post_fitler_x

    def get_acc_y_post_fitler(self):
        return self.acc_post_fitler_y

    def get_acc_z_post_fitler(self):
        return self.acc_post_fitler_z

    def fitler_jerk(self, data):
        tolerance = 0  # counts number of 0's between sign changes.
        potential_jerk_flag = False
        temp_data = copy.deepcopy(data)
        for i in range(len(data)):
            # print(data[i], "tolerance: "+str(tolerance))
            if (10 >= tolerance >= 5):
                if (i+1 < len(data)-1 and data[i+1] != float(0)):
                    # jerk is detected.
                    for j in range(i, i+25):
                        # flatten the jerk window (approx 30 packets ahead of the )
                        temp_data[j] = float(0)
                        potential_jerk_flag = False  # reset
                    tolerance = 0  # reset
                    # print("HERE", str(tolerance))
            if (tolerance > 11):
                potential_jerk_flag = False
                tolerance = 0
            if potential_jerk_flag and data[i] == float(0):
                tolerance += 1
            # encountered a crossing from + -> - or - -> +
            if (i+1 < len(data) and data[i] != float(0) and data[i+1] == float(0)):
                # set warning for probable jerk and begin to count 0.
                potential_jerk_flag = True
        return temp_data

    def read_content(self):
        with open(self.file_name, 'r', newline='') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                # TODO: Allow for reading from averaged_x/y/z in the future
                temp_weighted_x = float(row["weighted_mean_x"])
                temp_weighted_y = float(row["weighted_mean_y"])
                temp_weighted_z = float(row["weighted_mean_z"])

                # Append to accelerometer data list.
                self.acc_x.append(temp_weighted_x)
                self.acc_y.append(temp_weighted_y)
                self.acc_z.append(temp_weighted_z)

        # print confirmation of completion.
        print(f"Filtering jerk data from {self.file_name}.")
        self.acc_post_fitler_z = self.fitler_jerk(self.acc_z)
        self.acc_post_fitler_x = self.fitler_jerk(self.acc_x)
        self.acc_post_fitler_y = self.fitler_jerk(self.acc_y)
        for i in range(len(self.acc_post_fitler_z)):
            self.list_acc_data.append(
                (self.acc_post_fitler_x[i], self.acc_post_fitler_y[i], self.acc_post_fitler_z[i]))
        print(
            f"Data successfully extracted and filtered from {self.file_name}.")


'''
Rough implementation of 1D kalman filter [X Y Z Acceleration ->(KF)-> X Y Z Displacement]
'''


class kalman_filter():

    def __init__(self, accelerometer_data):
        self.acc_data = accelerometer_data
        self.dt = 0.1  # Assuming a 0.01 second time step, adjust as needed
        # Initial state vector
        self.x = np.array([[0],  # Position along x
                           [0],  # Velocity along x
                           [0],  # Position along y
                           [0],  # Velocity along y
                           [0],  # Position along z
                           [0]])  # Velocity along z

        self.P = np.eye(6)  # Initial covariance matrix
        # State transition matrix
        self.F = np.array([[1, self.dt, 0,  0,  0,  0],
                           [0,  1, 0,  0,  0,  0],
                           [0,  0, 1, self.dt,  0,  0],
                           [0,  0, 0,  1,  0,  0],
                           [0,  0, 0,  0,  1, self.dt],
                           [0,  0, 0,  0,  0,  1]])
        # Control input matrix
        self.B = np.array([[(self.dt**2)/2, 0,         0],
                           [self.dt,        0,         0],
                           [0,         (self.dt**2)/2, 0],
                           [0,         self.dt,        0],
                           [0,         0,         (self.dt**2)/2],
                           [0,         0,         self.dt]])

        # Process noise covariance matrix
        self.q = 0.1  # Adjust based on empirical tuning
        self.Q = self.q * np.array([[self.dt**4/4, self.dt**3/2, 0,       0,       0,       0],
                                    [self.dt**3/2, self.dt**2,   0,
                                        0,       0,       0],
                                    [0,       0,       self.dt**4 /
                                        4, self.dt**3/2, 0,       0],
                                    [0,       0,       self.dt**3 /
                                        2, self.dt**2,   0,       0],
                                    [0,       0,       0,       0,
                                        self.dt**4/4, self.dt**3/2],
                                    [0,       0,       0,       0,       self.dt**3/2, self.dt**2]])

        # Corrected measurement matrix for acceleration measurements
        self.H = np.array([[0, 1, 0, 0, 0, 0],  # Measurement mapping for acceleration in X
                           # Measurement mapping for acceleration in Y
                           [0, 0, 0, 1, 0, 0],
                           [0, 0, 0, 0, 0, 1]])  # Measurement mapping for acceleration in Z

        # Measurement noise covariance matrix
        self.r = 0.1  # Adjust based on the known sensor noise
        self.R = self.r * np.eye(3)

        # Identity matrix
        self.I = np.eye(6)

    # Getters
    def get_data(self):
        return self.acc_data

    def get_dt(self):
        return self.dt

    def run_filter(self):
        positions = []
        for measurement in self.get_data():
            # Predict
            self.x = self.F @ self.x  # State prediction
            self.P = self.F @ self.P @ self.F.T + self.Q  # Covariance prediction
            # Update
            Z = np.array(measurement).reshape(3, 1)
            y = Z - (self.H @ self.x)  # Measurement residual
            S = self.H @ self.P @ self.H.T + self.R  # Residual covariance
            K = self.P @ self.H.T @ np.linalg.inv(S)  # Kalman gain
            self.x = self.x + (K @ y)  # State update
            self.P = (self.I - (K @ self.H)) @ self.P  # Covariance update

            # Store the position
            positions.append((self.x[0, 0], self.x[2, 0], self.x[4, 0]))

        return positions


# create data_container instance
data_arbiter = data_container()
# create kalman filter instance:
KF = kalman_filter(data_arbiter.get_acc_data())
# run the Kalman filter.
estimated_positions = KF.run_filter()

# --------------------------------------------------------Graphing-------------------------------------------------
'''
This section of the code purely deals with the graphing of the probabilistic data generated by the KF entity.
'''
# Unpack the positions into separate lists
# x_coords, y_coords, z_coords = zip(*estimated_positions)
# z is multplied by -1 because directions are inverted.
x_coords, y_coords, z_coords = zip(
    *[(x, y, -z) for x, y, z in estimated_positions])

# Unpack the accelerometer data into separate lists for x, y, and z
x_acc, y_acc, z_acc = zip(*data_arbiter.get_acc_data())

t = np.arange(len(x_acc)) * KF.get_dt()  # time axis for acceleration plots.
# Create a new figure for 3D plotting
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Plot the points
ax.scatter(x_coords, y_coords, z_coords, c='r', marker='o')

# Plot the lines connecting points
ax.plot(x_coords, y_coords, z_coords, label='Estimated travel path')

# Labels and title
ax.set_xlabel('X Position')
ax.set_ylabel('Y Position')
ax.set_zlabel('Z Position')
ax.set_title('Estimated Position Over Time')

# Show the first point in orange
ax.scatter(x_coords[0], y_coords[0], z_coords[0],
           c='orange', marker='o', s=100, label='Start')

# Show the last point in green
ax.scatter(x_coords[-1], y_coords[-1], z_coords[-1],
           c='green', marker='o', s=100, label='End')

# Showcase legend
ax.legend()

plt.show()

# Plot Z position over time.
plt.figure(figsize=(10, 3))
plt.plot(t, z_coords, label='Z position over time', color='purple')
# Scatter plot to show each point
plt.scatter(t, z_coords, color='orange')  # Choose a color that stands out
plt.title('Z position over time')
plt.xlabel('Time (seconds)')
plt.ylabel('m')
plt.legend()
plt.grid(True)
plt.show()

# Acceleration in X
plt.figure(figsize=(10, 3))
plt.plot(t, x_acc, label='X-Axis Acceleration', color='red')
plt.title('Acceleration in X')
plt.xlabel('Time (seconds)')
plt.ylabel('Acceleration (m/s^2)')
plt.legend()
plt.grid(True)
plt.show()

# Acceleration in Y
plt.figure(figsize=(10, 3))
plt.plot(t, y_acc, label='Y-Axis Acceleration', color='green')
plt.title('Acceleration in Y')
plt.xlabel('Time (seconds)')
plt.ylabel('Acceleration (m/s^2)')
plt.legend()
plt.grid(True)
plt.show()

# Acceleration in Z
plt.figure(figsize=(10, 3))
plt.plot(t, data_arbiter.get_acc_z_pre_fitler(),
         label='Z-Axis Acceleration', color='blue')
plt.title('Acceleration in Z pre-jerk removal')
plt.xlabel('Time (seconds)')
plt.ylabel('Acceleration (m/s^2)')
plt.legend()
plt.grid(True)
plt.show()

# acceleration in Z post fitler
plt.figure(figsize=(10, 3))
plt.plot(t, data_arbiter.get_acc_z_post_fitler(),
         label='Z-Axis Acceleration', color='green')
plt.title('Z-Axis Acceleration after removing Jerk')
plt.xlabel('Time (seconds)')
plt.ylabel('Acceleration (m/s^2)')
plt.legend()
plt.grid(True)
plt.show()
# --------------------------------------------------End of Graphing-------------------------------------------------
